# SQE: Using html { ... }, js { ... }, css { ... }

Overview

This document explains how to use the new block types in the SQE generator: [`html { ... }`](q_generator/src/items/html.rs:1), [`js { ... }`](q_generator/src/items/js.rs:1), and [`css { ... }`](q_generator/src/items/css.rs:1).

Block types

- [`html { ... }`](q_generator/src/items/html.rs:1)
  - Inserts raw HTML exactly where the block appears.
  - Use for placeholders (see "Placeholders") or markup fragments.

- [`css { ... }`](q_generator/src/items/css.rs:1)
  - The CSS text is wrapped in a <style> element and inserted inline where the block appears.
  - TODO: if you prefer consolidated head <style>, see "Best practices".

- [`js { ... }`](q_generator/src/items/js.rs:1)
  - Treated as a per-page setup script. The generator collects these and embeds them into PAGE_SCRIPTS so they are executed by the runtime.
  - Executed as an async IIFE (immediately-invoked async function), and may be re-run by the runtime when answers change.

Execution model

The runtime that executes page scripts is defined in [`q_generator/src/convert.rs`](q_generator/src/convert.rs:171). Key points:

- Scripts live in a per-page array called PAGE_SCRIPTS generated by the converter.
- The runtime calls `runScriptsForPage(...)` to execute each script; that function is implemented at [`q_generator/src/convert.rs`](q_generator/src/convert.rs:268).
- Each script object looks like { "script": "<source>" } or optionally { "id":"<placeholder-id>","script":"<source>" }.
- When a script object has an `id`, the runtime will target a placeholder element: querySelector('[data-sqe-fn="id"]').
- [`js { ... }`](q_generator/src/items/js.rs:1) blocks are emitted as objects without `id` by default (setup scripts). If you need a placeholder, create an [`html { ... }`](q_generator/src/items/html.rs:1) element with a matching data-sqe-fn and have your `js` write into it.

Accessing answers

The generator provides a small API accessible from your [`js { ... }`](q_generator/src/items/js.rs:1) code:

- [`window.SQE_ANSWERS`](q_generator/src/convert.rs:180): plain object where collected answers are stored.
- [`SQE.getAnswer(key)`](q_generator/src/convert.rs:248): returns the stored answer for key.
- [`SQE.setAnswer(key, value)`](q_generator/src/convert.rs:252): sets an answer programmatically and dispatches the `sqe:answer` event.
- [`SQE.collectAnswers()`](q_generator/src/convert.rs:180): re-scans DOM inputs with `data-sqe-key` and updates `window.SQE_ANSWERS` (supports radios, checkboxes => arrays, and text).
- The runtime wires `input`/`change`/`sqe:answer` events to call collectAnswers and re-run page scripts (see [`q_generator/src/convert.rs`](q_generator/src/convert.rs:266)).

Example usage

1) Simple placeholder + js renderer

html {
  <div data-sqe-fn="my_result"></div>
}
js {
  (async function(){
    const id = "my_result";
    function render() {
      const a = window.SQE_ANSWERS || {};
      const v = a["q1"];
      const res = (v === 1 || v === "1") ? "Yes" : (v === 0 || v === "0") ? "No" : "No answer";
      const target = document.querySelector('[data-sqe-fn="'+id+'"]');
      if (!target) return;
      target.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'text-block';
      d.textContent = res;
      target.appendChild(d);
    }
    // run once; runtime will re-run page scripts on input/change
    render();
  }());
}

2) Using SQE helpers

js {
  (function(){
    // prefer SQE APIs
    const val = SQE.getAnswer("q1");
    if (val === null || typeof val === 'undefined') {
      SQE.insert("No answer yet");
    } else {
      SQE.insert("Answer: " + String(val));
    }
  }());
}

Best practices

- Prefer [`js { ... }`](q_generator/src/items/js.rs:1) for logic and [`html { ... }`](q_generator/src/items/html.rs:1) for markup. Keep CSS in [`css { ... }`](q_generator/src/items/css.rs:1) blocks or consolidated head styles.
- Avoid heavy DOM manipulation inside high-frequency handlers; use the runtime's debounced re-run (30ms) to reduce churn.
- Use `SQE.getAnswer(key)` and `SQE.setAnswer(key, value)` for programmatic reads/writes; they ensure events and state remain consistent.
- For multi-select checkboxes, `SQE.collectAnswers()` stores an array for that key (so treat answers as arrays).
- If you need a script to run only once globally, put it on the first page or implement a guard (e.g., window.__my_init_done).
- Be careful with untrusted JS — code runs directly in page context. Consider sanitizing inputs or running in a worker if necessary.

Troubleshooting

- If answers look stale, open the console and check for `[SQE] collectAnswers:` debug logs (emitted by the runtime in [`q_generator/src/convert.rs`](q_generator/src/convert.rs:180)).
- If a placeholder doesn't update, ensure your [`html { ... }`](q_generator/src/items/html.rs:1) contains a matching `data-sqe-fn` id and that your `js { ... }` writes into it.
- To trigger updates programmatically, call `SQE.setAnswer(key, value)` — this dispatches `sqe:answer` and re-runs page scripts.

Migration from f { ... }

- The old `f { ... }` form executed functions and returned values directly; it has been removed.
- To migrate, create an `html { ... }` placeholder with a data-sqe-fn id and a `js { ... }` block that computes the same result and writes into the placeholder. See example above.

Reference files

- Runtime and script execution: [`q_generator/src/convert.rs`](q_generator/src/convert.rs:268)
- js item implementation: [`q_generator/src/items/js.rs`](q_generator/src/items/js.rs:1)
- html item implementation: [`q_generator/src/items/html.rs`](q_generator/src/items/html.rs:1)
- css item implementation: [`q_generator/src/items/css.rs`](q_generator/src/items/css.rs:1)