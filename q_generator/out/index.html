<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Demo Survey</title>
<style>
body{font-family: system-ui, -apple-system, Roboto, 'Segoe UI', Arial; padding:20px; max-width:900px; margin:auto;}
.page{display:none;}
.page.active{display:block;}
.controls{display:flex;justify-content:space-between;margin-top:18px;}
.question{margin:12px 0;padding:10px;border-radius:8px;background:#f8f8f8;}
fieldset.question{border:1px solid #ddd;padding:10px;border-radius:6px;}
.text-block{margin:8px 0;}
.page-indicator{text-align:center;margin-top:12px;color:#666}
button:disabled{opacity:.5;cursor:not-allowed}
</style>
</head><body>
<h1>Demo Survey</h1>
<div id="pages">
<section class="page" data-index="0">
<h2>page 1</h2>
<fieldset class="question" data-q="p0_q0"><legend>Do you prefer A?</legend><div><input type="radio" id="p0_q0_opt0" name="p0_q0" data-sqe-key="q1" data-sqe-value="1"> <label for="p0_q0_opt0">Yes</label></div><div><input type="radio" id="p0_q0_opt1" name="p0_q0" data-sqe-key="q1" data-sqe-value="0"> <label for="p0_q0_opt1">No</label></div></fieldset>
<div data-sqe-fn="p0_fn0"></div>
</section>
<section class="page" data-index="1">
<h2>other page</h2>
<div data-sqe-fn="p2_fn0"></div>
</section>
</div>
<div class="controls">
<div><button id="prevBtn">Previous</button></div>
<div><button id="nextBtn">Next</button></div>
</div>
<div id="saveBtnContainer" style="text-align:center; margin-top:20px; display:none;">
<button id="saveBtn">Save Answers</button>
</div>
<div class="page-indicator" id="pageIndicator"></div>
<script>
const PAGE_COUNT = 2;
const PAGE_SCRIPTS = [[{"script":"(function() {\n  try {\n    if (!window.SQE_ANSWERS) window.SQE_ANSWERS = {};\n    const inputs = document.querySelectorAll(\"input[name='p0_q0']\");\n    inputs.forEach(i => {\n      i.addEventListener('change', function(e) {\n        try {\n          const raw = this.dataset.sqeValue;\n          const num = Number(raw);\n          const val = (Number.isFinite(num) && raw !== '') ? num : raw;\n          // Prefer centralized collection when available so checkboxes/radios/text are normalized.\n          if (window.SQE && typeof window.SQE.collectAnswers === 'function') {\n            window.SQE.collectAnswers();\n          } else {\n            window.SQE_ANSWERS[\"q1\"] = val;\n          }\n          // Notify runtime that an answer changed.\n          document.dispatchEvent(new CustomEvent('sqe:answer', { detail: { id: \"q1\", value: val } }));\n        } catch (e) { console.error('SQE choose onchange handler error', e); }\n      });\n    });\n  } catch(e) { console.error('SQE choose init error', e); }\n}());"},{"script":"(function(){\n    const id = \"p0_fn0\";\n    function render() {\n      const a = window.SQE_ANSWERS || {};\n      const v = a[\"q1\"];\n      let res;\n      if (v === 1 || v === \"1\") {\n        res = \"You selected Yes — perform action X\";\n      } else if (v === 0 || v === \"0\") {\n        res = \"You selected No — perform action Y\";\n      } else {\n        res = \"No answer recorded for q1.\";\n      }\n      try {\n        const target = document.querySelector('[data-sqe-fn=\"'+id+'\"]');\n        if (!target) return;\n        // clear previous contents\n        target.innerHTML = '';\n        const d = document.createElement('div');\n        d.className = 'text-block';\n        d.textContent = res;\n        target.appendChild(d);\n      } catch(e) { console.error(\"sqe js render error\", e); }\n    }\n    // run once; runtime will re-run page scripts on input/change\n    render();\n  }());"}],[{"script":"(function(){\n    const id = \"p2_fn0\";\n    function render() {\n      const a = window.SQE_ANSWERS || {};\n      const v = a[\"q1\"];\n      let res;\n      if (v === 1 || v === \"1\") {\n        res = \"You selected Yes — perform action X\";\n      } else if (v === 0 || v === \"0\") {\n        res = \"You selected No — perform action Y\";\n      } else {\n        res = \"No answer recorded for q1.\";\n      }\n      try {\n        const target = document.querySelector('[data-sqe-fn=\"'+id+'\"]');\n        if (!target) return;\n        target.innerHTML = '';\n        const d = document.createElement('div');\n        d.className = 'text-block';\n        d.textContent = res;\n        target.appendChild(d);\n      } catch(e) { console.error(\"sqe js render error\", e); }\n    }\n    render();\n  }());"}]];
document.addEventListener("DOMContentLoaded", () => {
    // tiny runtime API for f { ... } scripts
    window.SQE = window.SQE || {};
    const SQE = window.SQE;
    
    // Collect answers from DOM inputs marked with data-sqe-key.
    // This lets user scripts read window.SQE_ANSWERS immediately without needing to manually gather values.
    // Improvements: support checkbox groups as arrays, robustly coerce numbers, and debug-log collected values.
    SQE.collectAnswers = SQE.collectAnswers || function() {
      window.SQE_ANSWERS = window.SQE_ANSWERS || {};
      const els = document.querySelectorAll("[data-sqe-key]");
      const seen = new Set();
      els.forEach(el => {
        const key = el.getAttribute("data-sqe-key");
        if (!key || seen.has(key)) return;
        seen.add(key);
        const group = Array.from(document.querySelectorAll('[data-sqe-key="'+key+'"]'));
        // Determine element kinds in the group
        const types = new Set(group.map(g => (g.type || g.tagName || '').toLowerCase()));
        // collect values
        if (types.has('checkbox')) {
          // collect array of checked values
          const vals = [];
          group.forEach(g => {
            try {
              if (g.checked) {
                const v = g.getAttribute('data-sqe-value') ?? g.value;
                vals.push(v);
              }
            } catch(e){}
          });
          window.SQE_ANSWERS[key] = vals;
          console.debug("[SQE] collectAnswers:", key, "=", vals);
        } else if (types.has('radio')) {
          // single value
          let val = null;
          group.forEach(g => { try { if (g.checked) val = g.getAttribute('data-sqe-value') ?? g.value; } catch(e){} });
          const num = Number(val);
          const final = (val === null) ? null : (Number.isFinite(num) && val !== '') ? num : val;
          window.SQE_ANSWERS[key] = final;
          console.debug("[SQE] collectAnswers:", key, "=", final);
        } else {
          // fall back to last non-empty value in group (e.g., text inputs)
          let val = null;
          group.forEach(g => { try { if (typeof g.value !== 'undefined' && g.value !== '') val = g.value; } catch(e){} });
          const num = Number(val);
          const final = (val === null) ? null : (Number.isFinite(num) && val !== '') ? num : val;
          window.SQE_ANSWERS[key] = final;
          console.debug("[SQE] collectAnswers:", key, "=", final);
        }
      });
    };
    
    // Debounced runner to reduce excessive runs on rapid input events
    let _sqeRunTimer = null;
    function runAllFunctionsDebounced() {
      if (_sqeRunTimer) clearTimeout(_sqeRunTimer);
      _sqeRunTimer = setTimeout(() => { _sqeRunTimer = null; runAllFunctions(); }, 30);
    }
    
    // Automatically update answers when inputs change or when custom sqe:answer events are dispatched.
    // When answers change we re-run all function blocks (f { ... }) across all pages so
    // function placeholders update immediately and stay correct even when navigating back/forward.
    function runAllFunctions() {
      try {
        for (let pi = 0; pi < PAGE_SCRIPTS.length; pi++) {
          const scriptsForPage = PAGE_SCRIPTS[pi];
          if (scriptsForPage && scriptsForPage.length > 0) {
            runScriptsForPage(pi, scriptsForPage);
          }
        }
      } catch (e) {
        // don't let a failure block other handlers
        console.error("Error running all page functions", e);
      }
    }
    // listen for a wider set of events (input + change + explicit sqe:answer)
    document.addEventListener('input', function() { try { SQE.collectAnswers(); runAllFunctionsDebounced(); } catch(e){} }, true);
    document.addEventListener('change', function() { try { SQE.collectAnswers(); runAllFunctionsDebounced(); } catch(e){} }, true);
    document.addEventListener('sqe:answer', function() { try { SQE.collectAnswers(); runAllFunctionsDebounced(); } catch(e){} });
    
    // insert plain text as a .text-block (escaped by using textContent)
    SQE.insert = SQE.insert || function(text) {
        const page = document.querySelector(".page.active");
        if (!page) return null;
        const div = document.createElement("div");
        div.className = "text-block";
        div.textContent = String(text);
        page.appendChild(div);
        return div;
    };
    
    // insert raw HTML (use with care)
    SQE.insertHTML = SQE.insertHTML || function(html) {
        const page = document.querySelector(".page.active");
        if (!page) return null;
        const div = document.createElement("div");
        div.className = "text-block";
        div.innerHTML = String(html);
        page.appendChild(div);
        return div;
    };
    
    SQE.getAnswer = SQE.getAnswer || function(key) {
        return (window.SQE_ANSWERS || {})[key];
    };
    
    SQE.setAnswer = SQE.setAnswer || function(key, val) {
        window.SQE_ANSWERS = window.SQE_ANSWERS || {};
        window.SQE_ANSWERS[key] = val;
        // dispatch the same event that choice-rendered inputs use
        document.dispatchEvent(new CustomEvent('sqe:answer', { detail: { id: key, value: val } }));
    };
    
    const pages = Array.from(document.querySelectorAll(".page"));
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const pageIndicator = document.getElementById("pageIndicator");
    
    let currentIndex = 0;
    const ran = new Array(PAGE_COUNT).fill(false);
    
    // Run all scripts for a page (each script is an object { id: "...", script: "..." })
    function runScriptsForPage(idx, scriptsArray) {
        if (!scriptsArray || !Array.isArray(scriptsArray) || scriptsArray.length === 0) return;
        try {
            // Ensure latest answers are collected before running page scripts.
            try { if (typeof SQE.collectAnswers === 'function') SQE.collectAnswers(); } catch(e) {}
 
            scriptsArray.forEach(s => {
                try {
                    if (!s || typeof s !== 'object') return;
                    const id = s.id || null;
                    const scriptText = s.script;
                    if (!scriptText) return;
                    // Guard: avoid executing empty scripts
                    if (!String(scriptText).trim()) return;
 
                    // Logging: show which script is about to run (trim for brevity)
                    try { console.debug("[SQE] runScriptsForPage: page", idx, "id", id, "scriptSnippet", String(scriptText).slice(0,120)); } catch(e){}
 
                    if (id) {
                        // function block with a placeholder target
                        const selector = '[data-sqe-fn="'+String(id).replace(/"/g,'\\"')+'"]';
                        const target = document.querySelector(selector);
                        if (!target) return;
                        // Clear previous output in the placeholder
                        target.innerHTML = '';
 
                        let exec;
                        try {
                            exec = new Function('return (async function(){\n' + scriptText + '\n})()')();
                        } catch(e) {
                            console.error("Error constructing function for", id, e);
                            return;
                        }
 
                        const handleResult = (res) => {
                            try {
                                if (res === null || typeof res === 'undefined') {
                                    // nothing to render
                                    return;
                                } else if (typeof res === 'string' || typeof res === 'number' || typeof res === 'boolean') {
                                    const d = document.createElement('div');
                                    d.className = 'text-block';
                                    d.textContent = String(res);
                                    target.appendChild(d);
                                } else if (res instanceof Node) {
                                    target.appendChild(res);
                                } else if (Array.isArray(res)) {
                                    res.forEach(item => {
                                        if (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') {
                                            const d = document.createElement('div');
                                            d.className = 'text-block';
                                            d.textContent = String(item);
                                            target.appendChild(d);
                                        } else if (item instanceof Node) {
                                            target.appendChild(item);
                                        } else {
                                            // fallback: stringify
                                            const d = document.createElement('pre');
                                            d.className = 'text-block';
                                            d.textContent = JSON.stringify(item, null, 2);
                                            target.appendChild(d);
                                        }
                                    });
                                } else {
                                    // object or other: stringify to pre
                                    const d = document.createElement('pre');
                                    d.className = 'text-block';
                                    d.textContent = JSON.stringify(res, null, 2);
                                    target.appendChild(d);
                                }
                            } catch (e) {
                                console.error("Error handling script result for function", id, e);
                            }
                        };
 
                        if (exec && typeof exec.then === 'function') {
                            exec.then(handleResult).catch(e => { console.error("Error running function", id, e); });
                        } else {
                            handleResult(exec);
                        }
                    } else {
                        // setup/side-effect script (no placeholder) — execute but ignore return value
                        try {
                            const exec = new Function('return (async function(){\n' + scriptText + '\n})()')();
                            if (exec && typeof exec.then === 'function') {
                                exec.catch(e => { console.error("Error running setup script", e); });
                            }
                        } catch (e) {
                            console.error("Error executing setup script", e);
                        }
                    }
                } catch(e){
                    console.error("Error executing script object", e);
                }
            });
        } catch (e) {
            console.error("Error running page scripts for page", idx + 1, e);
        }
    }
    
    function showPage(idx) {
        if (idx < 0) idx = 0;
        if (idx >= PAGE_COUNT) idx = PAGE_COUNT - 1;
        currentIndex = idx;
 
        pages.forEach((p, i) => {
            if (i === idx) {
                p.classList.add("active");
                p.style.display = "";
            } else {
                p.classList.remove("active");
                p.style.display = "none";
            }
        });
 
        if (prevBtn) prevBtn.disabled = (idx === 0);
        if (nextBtn) nextBtn.disabled = (idx === PAGE_COUNT - 1);
        if (pageIndicator) pageIndicator.textContent = "Page " + (idx + 1) + " of " + PAGE_COUNT;
        const saveContainer = document.getElementById("saveBtnContainer");
        if (saveContainer) {
            if (idx === PAGE_COUNT - 1) {
                saveContainer.style.display = "block";
            } else {
                saveContainer.style.display = "none";
            }
        }
 
        try {
            const scriptsForPage = PAGE_SCRIPTS[idx];
            if (scriptsForPage && scriptsForPage.length > 0) {
                runScriptsForPage(idx, scriptsForPage);
                ran[idx] = true;
            }
        } catch (e) {
            console.error("Error running page scripts for page", idx + 1, e);
        }
    }
 
    if (prevBtn) {
        prevBtn.addEventListener("click", () => { showPage(currentIndex - 1); });
    }
    if (nextBtn) {
        nextBtn.addEventListener("click", () => { showPage(currentIndex + 1); });
    }
 
    showPage(0);
});

document.addEventListener("DOMContentLoaded", () => {
    const saveBtn = document.getElementById("saveBtn");
    if (saveBtn) {
        saveBtn.addEventListener("click", () => {
            const data = JSON.stringify(window.SQE_ANSWERS || {}, null, 2);
            const blob = new Blob([data], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "answers.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    }
});

</script>
</body></html>
